%% GET_LOVE
% AUTHOR: M. Rovira-Navarro 
% USE: obtain the tidal love number spectra for an interior model with lateral variations
%% INPUT 
% Interior_Model: Structure containing the interior model information
    % Mean properties: 
        %Interior_Model(ilayer).R0: radius [km]
        %Interior_Model(ilayer).rho0: density [kg.m^{-3}]       
        %Interior_Model(ilayer).mu0: shear modulus [Pa]
        %Interior_Model(ilayer).Ks0: bulk modulus, if not given, the model is assumed incompressible, [Pa]
        %Interior_Model(ilayer).eta0: viscosity, if not give, the body is assumed elastic [Pa.s]
        %Interior_Model(ilayer).MaxTime: normalized Maxwell time, it can be given instead of the viscosity, else it is computed [-]
        %Interior_Model(ilayer).ocean: (0) no ocean, (1) ocean
        %Interior_Model(ilayer).Gg0: gravitational constant (should be equal for all layers) [Nm^2kg^{-2}]
    % Lateral variations 
    % Lateral variations can be provided in three different formats
    %%% (1) in complex spherical harmonics: 
        %Interio_Model(ilayer).mu_variable: shear modulus variations
            %mu_variable(:,1): degree of variation 
            %mu_variable(:,2): order of variation 
            %mu_variable(:,3): amplitude of the variation (mu_l^m/mu^0_0)
        %Interio_Model(ilayer).K_variable: bulk modulus variations 
            %K_variable(:,1): degree of variation 
            %K_variable(:,2): order of variation 
            %K_variable(:,3):  amplitude of bulk modulus variations (K_l^m/K^0_0)
        %Interio_Model(ilayer).eta_variable: viscosity
            %eta_variable(:,1): degree of variation 
            %eta_variable(:,2): order of variation 
            %eta_variable(:,3):  amplitude of viscosity variations (eta_l^m/eta^0_0)
    %%% (2) in peak to peak variation amplitude wrt to the mean value (in percent)
        %Interio_Model(ilayer).mu_variable_p2p: shear modulus variations
            %mu_variable_p2p(:,1): degree of variation 
            %mu_variable_p2p(:,2): order of variation 
            %mu_variable_p2p:,3): amplitude of the variation (mu_l^m/mu^0_0)
        %Interio_Model(ilayer).K_variable_p2p: bulk modulus variations 
            %K_variable_p2p(:,1): degree of variation 
            %K_variable_p2p(:,2): order of variation 
            %K_variable_p2p(:,3):  amplitude of bulk modulus variations (K_l^m/K^0_0)
        %Interio_Model(ilayer).eta_variable: viscosity
            %eta_variable_p2p(:,1): degree of variation 
            %eta_variable_p2p(:,2): order of variation 
            %eta_variable_p2p(:,3):  amplitude of viscosity variations (eta_l^m/eta^0_0)  
    %%% (3) as a map, in which case get_rheology will transform it to
            % a spherical harmonics expansion. The maps can be generated by generated SPH_LatLon in SPH_Tools and 
            % for efficient transformation should be evaluated in the lat lon grid specified there, 
            % which depends on the maximum degree of the expansion. 
            % IMPORTANT NOTICE: The map(s) should already be scaled by their relevant average value 
            % (Interior_Model(ilayer).eta0, Interior_Model(ilayer).mu0 or Interior_Model(ilayer).Ks0) as: 
                    % Interior_Model(ilayer).mu_latlon/Interior_Model(ilayer).mu0
                    % Interior_Model(ilayer).eta_latlon/Interior_Model(ilayer).eta0
                    % Interior_Model(ilayer).K_latlon/Interior_Model(ilayer).Ks0
            % This ensures that the maps that you input have a mean of 1, which is what
            % the code expects, and that the actual fields have an average equal
            % to the prescribed average (Interior_Model(ilayer).XXX0)
            % Each of the input fields has the components 
                    %.lon:  longitude [IN DEGREES]
                    %.lat:  latitude [IN DEGREES]
                    %.z:    pxq grid where p stands for latitude and q for
                    %.lmax: maximum harmonic degree
            % for both (1) and (2) the expansion in spherical harmonics should result in 
            % a real field (there should be both m>0 and m<0 components)
            % If this is not the case the and only >0 components are provided, the <0 component is computed
    % Assigned in get_rheology 
    %%% Mean properties: 
        % Interior_Model(ilayer).R: normalized radius (normalized with Interior_Model(end).R0)
        % Interior_Model(ilayer).rho: normalized density  (normalized with Interior_Model(end).rho0)     
        % Interior_Model(ilayer).mu: normalized shear modulus of the layer (normalized with Interior_Model(end).mu0)
        % Interior_Model(ilayer).Ks: normalized bulk modulus of layer (normalized with Interior_Model(end).mu0)
        % Interior_Model(ilayer).Ks: normalized viscosity of layer (normalized with Interior_Model(end).mu0*Forcing.T)
        % Interior_Model(ilayer).Gg: normalized gravitational constant (can also be given by user in model given in non-dimensional units)
        % Interior_Model(ilayer).gs: normalized gravity at Interior_Model(ilayer).R0
        % Interior_Model(ilayer).gs0: gravity at Interior_Model(ilayer).R0
        %Interior_Model(ilayer).muC: normalized complex shear modulus 
        % Interior_Model(ilayer).mu00R: normalized real component of the shear modulus 
         % Interior_Model(ilayer).rho0_av: averaged denseity at Interior_Model(ilayer).R0
        % Interior_Model(ilayer).rho_av: normalized averaged denseity at Interior_Model(ilayer).R0
     %%% Lateral variations:
        % Interior_Model(ilayer).rheology_variable: rheology variable 
        % rheology_variable(:,1): degree of variation 
        % rheology_variable(:,2): order of variation 
        % rheology_variable(:,3): amplitude of bulk modulus variations (K_l^m/K^0_0)  
        % rheology_variable(:,4): amplitude of complex shear modulus variations (\hat mu_l^m/mu^0_0(N))
 %---------------------
    % Forcing: Structure containing forcing information
        % Forcing.Td: forcing period
        % Forcing.n: degree of the forcing 
        % Forcing.m: order of the forcing 
        % Forcing.F: amplitude of the component 
 %---------------------
    % Numerics
        %Numerics.Nlayers: number of layers, simply length(Interior_Model)
        %Numerics.method: used for the radial discretization in set_boundary_indices. Four methods are possible 
        %   - variable: This method sets the number of radial points in each layer
        %       equal to Numerics.Nrbase. The variable name thus comes from the fact
        %       that the stepsize is variable. 
        %   - fixed: This method sets the total number of points equal to Nrbase.
        %       Same as for the variable method, the name fixed thus means that the
        %       stepsize is kept fixed. WARNING: This method changes the physical
        %       boundary locations to ensure that they occur at a integer number of
        %       points.
        %    - combination: This method is a combination of the fixed and variable
        %       method. Numerics.Nrbase serves as the base number of points per layer
        %       onto which an additional number of points is added based on the
        %       physical size of the layer. The total number of points will depend on
        %       the number of layers but is roughly given by (Nlayers+1)*Nrbase
        %   - manual: This method allows the user to set the number of points per 
        %       layer manually. In order for it to work an array needs to be
        %       provided as a varargin after putting 'manual' as a varargin as well. 
        %       The syntax of the array needs to be: [0, points in layer #1, points
        %       in layer #2, etc]
        %Numerics.Nrbase: used for the radial discretization  (see above) 
        %Numerics.Nr: number of radial points (computed inside set_boundary_indices)
        %Numerics.Nrlayer(layer): number of radial points per layer (computed inside set_boundary_indices)
        %Numerics.BCindices(layer): indec of the layer point at the boundaries
        %Numerics.perturbation_order: maximum order of the perturbation. Default 2
        %Numerics.rheology_cutoff: determines which terms of the rheology are included (only relevant for viscoelastic). terms with log10(mu_n^m)-log10(mu_n^m(leading))>=-Numerics.rheology_cutoff are included. Default 0 (only leading terms)
        %Numerics.Nenergy: maximum degree to which energy dissipation is expanded. Defaulft 8. 
        %Numerics.load_couplings: 
             % (0) compute coupling coefficients
             % (1) load coupling coefficients from file that contains ALL coupling up to rheology variations of a degree higher than those specied, if such a file does not exist compute it   (default) 
             % (2) load coupling coefficients from a file that contains specifically the coupling coefficients for the rheology specied, if it does not exisit, compute it. 
        % Numerics.parallel_sol  Calculate the solution using a parfor-loop either 0 or 1
        % Numerics.parallel_gen  Calculate potential coupling files using parfor-loops either 0 or 1
         
    % optional variables 
        %plot_rheology_spectra: plot rheology spectra (1)
        %verbose: print information in screen (1)
        %out_file: print output in file named out_file
%% OUTPUT 
    % Love_Spectra: Love number spectra
        % Love_Spectra.nf: degree of the forcing 
        % Love_Spectra.mf: order of the forcing 
        % Love_Spectra.n: degree of the solution
        % Love_Spectra.m: order of the solution
        % Love_Spectra.k: gravity Love numbers
        % Love_Spectra.h: radial displacement Love numbers
    % y_rad: radial functions
        % y_rad.nf: degree of the forcing
        % y_rad.mf: order of the forcing 
        % y_rad.n: degree of the solution
        % y_rad.m: order of the solution 
        % y_rad.y(radial_point,X,mode) 
            % y(radial_point,1,mode): r radial position
            % y(radial_point,2,mode): U radial displacement
            % y(radial_point,3,mode): V tangential displacement
            % y(radial_point,4,mode): W toroidal displacement 
            % y(radial_point,5,mode): R radial stress
            % y(radial_point,6,mode): S tangential stress
            % y(radial_point,7,mode): T toroidal stress
            % y(radial_point,8,mode): \phi toroidal potential
            % y(radial_point,9,mode): \partial_r\phi potentia derivative       
            % y(radial_point,10,mode): u_{n,n-1}
            % y(radial_point,11,mode): u_{n,n}
            % y(radial_point,12,mode): u_{n,n+1}
            % y(radial_point,13,mode): \sigma_{n,n,0}       
            % y(radial_point,14,mode): \sigma_{n,n-2,2}
            % y(radial_point,15,mode): \sigma_{n,n-1,2}
            % y(radial_point,16,mode): \sigma_{n,n,2}
            % y(radial_point,17,mode): \sigma_{n,n+1,2}
            % y(radial_point,18,mode): \sigma_{n,n+2,2}      
            % y(radial_point,19,mode): \epsilon_{n,n,0}
            % y(radial_point,20,mode): \epsilon_{n,n-2,2}
            % y(radial_point,21,mode): \epsilon_{n,n-1,2}
            % y(radial_point,22,mode): \epsilon_{n,n,2}
            % y(radial_point,23,mode): \epsilon{n,n+1,2}
            % y(radial_point,24,mode): \epsilon_{n,n+2,2}
   % varargout{1}: Interior_Model updated with variables non-dimensionalized         
%% FUNCTION ------------------------------------------------------------------   
function [Love_Spectra,y_rad,varargout] = get_Love(Interior_Model,Forcing,Numerics,varargin)
verbose = 0; 
out_file = 0; 
save_solution_vec = 0;
%% (0) Optional Inputs Defaults -----------------------------------------------------
if isfield(Numerics,'Nr')==0
    Numerics.Nr=100;
end
if isfield(Numerics,'rheology_cutoff')==0
    Numerics.rheology_cutoff=2;
end
if isfield(Numerics,'load_couplings')==0
    Numerics.load_couplings=1;
end
if isfield(Numerics,'perturbation_order')==0
    Numerics.perturbation_orders=2;
end
if isfield(Numerics,'solution_cutoff')==0
    Numerics.perturbation_orders=0;
    Numerics.solution_cutoff=8;
end

for k = 1:length(varargin)
    if strcmpi(varargin{k},'verbose')
        verbose=1; 
        varargin{k}=[];
    end
    if strcmpi(varargin{k},'out_file')
        out_file=varargin{k+1}; 
        varargin{k+1}=[]; 
        varargin{k}=[];
    end
    if strcmpi(varargin{k},'save_location')
        save_location=varargin{k+1}; 
        varargin{k+1}=[]; 
        varargin{k}=[];
    end
    if strcmpi(varargin{k},'save_solution')
        save_solution_vec=varargin{k+1}; 
        varargin{k+1}=[]; 
        varargin{k}=[];
    end
end

%% (0.1) File for printing -------------------------------------------------------------------
% Obtain the highest degree of rheology across the layers that is used
Numerics.Nrheo_max = 0;
for ilayer=2:Numerics.Nlayers
    prevmax = max(Interior_Model(ilayer).rheology_variable(:,1));
    Numerics.Nrheo_max = max([Numerics.Nrheo_max prevmax]);
end

if out_file~=0
    out_file_name=[save_location out_file '__' num2str(Numerics.Nrheo_max) '_per' num2str(Numerics.rheology_cutoff) ...
        '__forc__' num2str(Forcing.n) '_' num2str(Forcing.m) '_per' num2str(Numerics.perturbation_order) '.txt'];
    FID=fopen(out_file_name,'w');
    out_file_name_y=[save_location 'y__' num2str(Numerics.Nrheo_max) '_per' num2str(Numerics.rheology_cutoff) ...
        '__forc__' num2str(Forcing.n) '_' num2str(Forcing.m) '_per' num2str(Numerics.perturbation_order) '.mat'];
end

%% (2) OBTAIN COUPLINGS --------------------------------------------------------------
if verbose==1
    disp('Obtaining Couplings....')
    tic
end

% Check whether there are any uniform layers
uniformlayers = [];
for ilayer=2:Numerics.Nlayers
    uniformlayers = [uniformlayers Interior_Model(ilayer).uniform];
end

% Inverse boolean, non-uniform layers are now 1
uniformlayers = uniformlayers == 0;

% If there is only one non-uniform layer obtain couplings
if any(uniformlayers) 
    % Remove rheology terms with 0 amplitude 
    % Fill an array with all the used degree and orders (contains duplicates)
    for ilayer=2:Numerics.Nlayers
        non_zero_rheo = find(abs(Interior_Model(ilayer).rheology_variable(:,4)) > 0);
        Interior_Model(ilayer).rheology_variable = Interior_Model(ilayer).rheology_variable(non_zero_rheo,:);
        if ilayer == 2
            rheo_degree_orders = Interior_Model(ilayer).rheology_variable(:,1:2);
        else
            rheo_degree_orders = [rheo_degree_orders ; Interior_Model(ilayer).rheology_variable(:,1:2)];
        end
    end

    % Remove duplicates from rheo_degree_orders
    rheo_degree_orders = unique(rheo_degree_orders,'rows');

    % Decide whether to load from a file containing all the modes for this specific rheology and settings 
    % or coupling coefficients from a large generic file

    if Numerics.load_couplings == 1 % Load from specific file
        % Generate coupling file name
        str_rheo = [];
        for i=1:size(rheo_degree_orders,1)
            str_rheo = [str_rheo num2str(rheo_degree_orders(i,1)) '_' num2str(rheo_degree_orders(i,2)) '__'];
        end
        coupling_file_name = [Numerics.coupling_file_location 'L_rheo__' str_rheo 'forc__' ... 
                              num2str(Forcing.n) '_' num2str(Forcing.m) '.mat'];
        
        if isfile(coupling_file_name)==1 % Load couplings
            if verbose==1
                disp(['Coupling Loaded from: ' coupling_file_name])
            end
            
            % Load couplings file
            Couplings = load(coupling_file_name);
            
            if verbose==1
                disp(['Loading coupling file took: ' num2str(toc) ' seconds'])
            end
        else % Compute couplings
            if verbose==1
                tic
                disp(['File ' coupling_file_name 'not found. Computing all coupling coefficients, this might take some time..'])
                Couplings = get_couplings(rheo_degree_orders,Forcing,Numerics,'verbose');
                disp(['Time Spent: ' num2str(toc) 's'])
                disp([' File stored in: ' coupling_file_name])
            else
                Couplings = get_couplings(rheo_degree_orders,Forcing,Numerics);
            end
            Couplings.n_r = rheo_degree_orders(:,1);
            Couplings.m_r = rheo_degree_orders(:,2);
            
            % Save couplings for all terms
            save(coupling_file_name,'-struct','Couplings','-v7.3')
        end

    elseif Numerics.load_couplings == 2 % Load from bigger/generic file
        % Generate coupling file name
        coupling_file_name = [Numerics.coupling_file_location 'L_struct__Nrheomax__' num2str(Numerics.Nrheo_max) '__forc__' ...
            num2str(Forcing.n) '_' num2str(Forcing.m) '_per' num2str(Numerics.perturbation_order) '.mat'];
    
        % Look if there is a file that contains the couplings
        coupling_file_name_search = [Numerics.coupling_file_location 'L_struct__Nrheomax__*__forc__' num2str(Forcing.n) ...
                                  '_' num2str(Forcing.m) '_per*.mat'];
        possible_couplings_files = dir(coupling_file_name_search);
        file_found = 0;
        i = 1; 
        potential_coupling_files = [];
        rheo_max_file_list = [];
    
        % Select the smallest possible file that contains all the couplings
        while i<=length(possible_couplings_files)
            per_start = strfind(possible_couplings_files(i).name,'_per')+4;
            per_end = strfind(possible_couplings_files(i).name,'.mat')-1;
            perturbation_order_file = str2num(possible_couplings_files(i).name(per_start:per_end));
            rheo_start = strfind(possible_couplings_files(i).name,'Nrheomax__')+10;
            rheo_end = strfind(possible_couplings_files(i).name,'__forc')-1;
            Nrheomax_file = str2num(possible_couplings_files(i).name(rheo_start:rheo_end));
    
            % Check whether the file fullfills the criteria and add it to the list
            if Nrheomax_file>=Numerics.Nrheo_max && perturbation_order_file>=Numerics.perturbation_order 
                interim_name = [Numerics.coupling_file_location possible_couplings_files(i).name];
                potential_coupling_files = [potential_coupling_files convertCharsToStrings(interim_name)];
                rheo_max_file_list = [rheo_max_file_list Nrheomax_file];
            end
            i=i+1;
        end
    
        % If suitable files have been found select the smallest one
        if ~isempty(potential_coupling_files)
            [~,ind] = min(rheo_max_file_list);
            coupling_file_name = potential_coupling_files(ind);
            file_found = 1;
        end  
        
        % Load the coupling file
        if file_found==1 % Coupling file exist 
            if verbose==1
                disp([' Couplings Loaded from: ' convertStringsToChars(coupling_file_name)])
            end
    
            % Retrieve the coupling coefficients that are required
            if verbose==1
                tic
            end
            Couplings = retrieve_couplings_from_file(Numerics.perturbation_order,rheo_degree_orders,Forcing,coupling_file_name);
            if verbose==1
                disp(['Loading coupling file took: ' num2str(toc) ' seconds'])
            end
        else % Compute couplings 
            if verbose==1
                tic
                disp(['File ' coupling_file_name 'not found. Computing all coupling coefficients, this might take some time..'])
                Couplings = get_couplings_all(Forcing,Numerics,'verbose');
                disp(['Time Spent: ' num2str(toc) 's'])
                disp([' File stored in: ' coupling_file_name])
            else
                Couplings = get_couplings_all(Forcing,Numerics);
            end
    
            % Save couplings for all terms
            save(coupling_file_name,'-struct','Couplings','-v7.3')
    
            % Retrieve the coupling coefficients that are required
            Couplings = retrieve_couplings(Numerics.perturbation_order,rheo_degree_orders,Forcing,Couplings);
        end
    end
    
else
    if verbose==1
        disp('Only uniform layers so coupling matrix is zero')
    end
    Couplings.n_s = Forcing.n;
    Couplings.m_s = Forcing.m;
    Couplings.order = 0;
    Couplings.Coup = zeros(1,1,27,1); 
end

Nsol = length(Couplings.n_s);

%% PRINT MODEL INFORMATION IN SCREEN 
if verbose==1
    cprintf('*black','------------- INTERIOR MODEL ----------- \n')
    disp('AVERAGE PROPERTIES (dimensional)')
    disp(['Layer#     R[m]    rho[kg.m^{-3}]    mu[Pa]    K[Pa]    eta[Pa.s]' ])
    disp(['1    ' num2str(Interior_Model(1).R0,'%10.5e') '    ' num2str(Interior_Model(1).rho0,'%10.5e') '    0'  '    -'   ])
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'ocean')
            if Interior_Model(ilayer).ocean
                cprintf('blue',[num2str(ilayer) '    ' num2str(Interior_Model(ilayer).R0,'%10.5e') '    ' num2str(Interior_Model(ilayer).rho0,'%10.5e') '    ' num2str(Interior_Model(ilayer).mu0,'%10.5e')  '    ' num2str(Interior_Model(ilayer).Ks0,'%10.5e') ' ' num2str(Interior_Model(ilayer).eta0,'%10.5e') '\n'   ])
            else
                disp([num2str(ilayer) '    ' num2str(Interior_Model(ilayer).R0,'%10.5e') '    ' num2str(Interior_Model(ilayer).rho0,'%10.5e') '    ' num2str(Interior_Model(ilayer).mu0,'%10.5e')  '    ' num2str(Interior_Model(ilayer).Ks0,'%10.5e') ' ' num2str(Interior_Model(ilayer).eta0,'%10.5e')   ])
            end
        else
            disp([num2str(ilayer) '    ' num2str(Interior_Model(ilayer).R0,'%10.5e') '    ' num2str(Interior_Model(ilayer).rho0,'%10.5e') '    ' num2str(Interior_Model(ilayer).mu0,'%10.5e')  '    ' num2str(Interior_Model(ilayer).Ks0,'%10.5e') ' ' num2str(Interior_Model(ilayer).eta0,'%10.5e')   ])
        end       
    end
    disp('AVERAGE PROPERTIES (non-dimensional)')
    disp(['Layer#     R[-]    rho[-]    mu[-]    K [-]     eta[-]' ])
    disp(['1    ' num2str(Interior_Model(1).R) '    ' num2str(Interior_Model(1).rho) '    0'  '    -'   ])
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'ocean')
            if Interior_Model(ilayer).ocean
                cprintf('blue',[num2str(ilayer) '    ' num2str(Interior_Model(ilayer).R) '    ' num2str(Interior_Model(ilayer).rho) '    ' num2str(Interior_Model(ilayer).mu)  '    ' num2str(Interior_Model(ilayer).Ks) ' ' num2str(Interior_Model(ilayer).eta)  '\n'  ])
            else
                disp([num2str(ilayer) '    ' num2str(Interior_Model(ilayer).R) '    ' num2str(Interior_Model(ilayer).rho) '    ' num2str(Interior_Model(ilayer).mu)  '    ' num2str(Interior_Model(ilayer).Ks) ' ' num2str(Interior_Model(ilayer).eta)   ])
            end
        else
            disp([num2str(ilayer) '    ' num2str(Interior_Model(ilayer).R) '    ' num2str(Interior_Model(ilayer).rho) '    ' num2str(Interior_Model(ilayer).mu)  '    ' num2str(Interior_Model(ilayer).Ks) ' ' num2str(Interior_Model(ilayer).eta)   ])
        end
    end
    disp('RHEOLOGY  VARIATIONS')
    disp('Shear Modulus')
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model(ilayer),'mu_variable')==1
            disp('Layer#      (n,m)           amplitude[mu_n^m/mu_0^0]')
            for i=1:size(Interior_Model(ilayer).mu_variable,1)
                disp([num2str(ilayer) '    (' num2str(Interior_Model(ilayer).mu_variable(i,1)) ',' num2str(Interior_Model(ilayer).mu_variable(i,2)) ')   '  num2str(Interior_Model(ilayer).mu_variable(i,3),'%10.5e') ])
            end
        else
            disp('None')
        end 
    end
    
    disp('Bulk Modulus')
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'K_variable')==1
            disp('Layer#      (n,m)           amplitude[K_n^m/K_0^0]')
            for i=1:size(Interior_Model(ilayer).K_variable,1)
                disp([num2str(ilayer) '    (' num2str(Interior_Model(ilayer).K_variable(i,1)) ',' num2str(Interior_Model(ilayer).K_variable(i,2)) ')   '  num2str(Interior_Model(ilayer).K_variable(i,3),'%10.5e') ])
            end
        else
            disp('None')
        end
    end

    disp('Viscosity')
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'eta_variable')==1
            disp('Layer#      (n,m)          amplitude[eta_n^m/eta_0^0]')
            for i=1:size(Interior_Model(ilayer).eta_variable,1)
                disp([num2str(ilayer) '    (' num2str(Interior_Model(ilayer).eta_variable(i,1)) ',' num2str(Interior_Model(ilayer).eta_variable(i,2)) ')   '  num2str(Interior_Model(ilayer).eta_variable(i,3),'%10.5e') ])
            end
        else
            disp('None')
        end
    end
    
    disp('Complex Shear Modulus')
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'rheology_variable')==1
            disp('Layer#      (n,m)         amplitude[\hat\mu_n^m/mu_0^0]')
            for i=1:size(Interior_Model(ilayer).rheology_variable,1)
                disp([num2str(ilayer) '    (' num2str(Interior_Model(ilayer).rheology_variable(i,1)) ',' num2str(Interior_Model(ilayer).rheology_variable(i,2)) ')    '  num2str(Interior_Model(ilayer).rheology_variable(i,4),'%10.5e') ])
            end
        else
            disp('None')
        end
    end
    disp(' ')
    cprintf('*black','----------- FORCING ----------\n')
    disp('TIDAL POTENTIAL')
    disp('Period [s]')
    disp(num2str(Forcing.Td,'%10.5e'))
    disp('(n,m)')
    disp(['(' num2str(Forcing.n) ',' num2str(Forcing.m) ')'])
    disp(' ')
    cprintf('*black','-----------  RESPONSE SPECTRUM -----------\n')
    for j=0:Numerics.perturbation_order
    index_order=find(Couplings.order==j);
    str_h=[];
    for k=1:length(index_order)
        str_h=[str_h '(' num2str(Couplings.n_s(index_order(k))) ',' num2str(Couplings.m_s(index_order(k))) '),   '];
    end
    disp([num2str(j) 'th Order Modes'])
    if j==0
        disp('1 modes')
        disp(['(' num2str(Forcing.n) ',' num2str(Forcing.m) '),   '])
    else
    disp([num2str(length(index_order)) ' modes'])
    disp(str_h)
    end
    end
    cprintf('*black','----------- NUMERICAL INFORMATION ----------\n')
    disp(['Number of Modes ' num2str(Nsol)])
    disp(['Radial Points '  num2str(Numerics.Nr)])
end
%% PRINT MODEL INFORMATION IN FILE
if out_file~=0
    fprintf(FID, '%s\n','------------- INTERIOR MODEL -----------');
    fprintf(FID, '%s\n', 'AVERAGE PROPERTIES (dimensional)');
    fprintf(FID, '%s\n', ['Layer#     R[m]    rho[kg.m^{-3}]    mu[Pa]    K[Pa]    eta[Pa.s]' ]);
    fprintf(FID, '%s\n', ['1    ' num2str(Interior_Model(1).R0,'%10.5e') '    ' num2str(Interior_Model(1).rho0,'%10.5e') '    0'  '    -'   ]);
    for ilayer=2:Numerics.Nlayers
        fprintf(FID, '%s\n', [num2str(ilayer) '    ' num2str(Interior_Model(ilayer).R0,'%10.5e') '    ' num2str(Interior_Model(ilayer).rho0,'%10.5e') '    ' num2str(Interior_Model(ilayer).mu0,'%10.5e')  '    ' num2str(Interior_Model(ilayer).Ks0,'%10.5e') ' ' num2str(Interior_Model(ilayer).eta0,'%10.5e')   ]);
    end
    fprintf(FID, '%s\n', 'AVERAGE PROPERTIES (non-dimensional)');
    fprintf(FID, '%s\n', ['Layer#     R[-]    rho[-]    mu[-]    K [-]     eta[-]' ]);
    fprintf(FID, '%s\n', ['1    ' num2str(Interior_Model(1).R) '    ' num2str(Interior_Model(1).rho) '    0'  '    -'   ]);
    for ilayer=2:Numerics.Nlayers
        fprintf(FID, '%s\n', [num2str(ilayer) '    ' num2str(Interior_Model(ilayer).R) '    ' num2str(Interior_Model(ilayer).rho) '    ' num2str(Interior_Model(ilayer).mu)  '    ' num2str(Interior_Model(ilayer).Ks) ' ' num2str(Interior_Model(ilayer).eta)   ]);
    end
    fprintf(FID, '%s\n', 'RHEOLOGY  VARIATIONS');
    fprintf(FID, '%s\n', ['Rheology cutoff =        ' num2str(Numerics.rheology_cutoff)]);
    fprintf(FID, '%s\n', 'Shear Modulus');
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'mu_variable')==1
            fprintf(FID, '%s\n', 'Layer#      (n,m)           amplitude[mu_n^m/mu_0^0]');
            for i=1:size(Interior_Model(ilayer).mu_variable,1)
                fprintf(FID, '%s\n', [num2str(ilayer) '    (' num2str(Interior_Model(ilayer).mu_variable(i,1)) ',' num2str(Interior_Model(ilayer).mu_variable(i,2)) ')   '  num2str(Interior_Model(ilayer).mu_variable(i,3),'%10.5e') ]);
            end
        else
            fprintf(FID, '%s\n', 'None');
        end 
    end
    
    fprintf(FID, '%s\n', 'Bulk Modulus');
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'K_variable')==1
            fprintf(FID, '%s\n', 'Layer#      (n,m)           amplitude[K_n^m/K_0^0]');
            for i=1:size(Interior_Model(ilayer).K_variable,1)
                fprintf(FID, '%s\n', [num2str(ilayer) '    (' num2str(Interior_Model(ilayer).K_variable(i,1)) ',' num2str(Interior_Model(ilayer).K_variable(i,2)) ')   '  num2str(Interior_Model(ilayer).K_variable(i,3),'%10.5e') ]);
            end
        else
            fprintf(FID, '%s\n', 'None')
        end
    end

    fprintf(FID, '%s\n', 'Viscosity');
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'eta_variable')==1
            fprintf(FID, '%s\n', 'Layer#      (n,m)          amplitude[eta_n^m/K_0^0]');
            for i=1:size(Interior_Model(ilayer).eta_variable,1)
                fprintf(FID, '%s\n', [num2str(ilayer) '    (' num2str(Interior_Model(ilayer).eta_variable(i,1)) ',' num2str(Interior_Model(ilayer).eta_variable(i,2)) ')   '  num2str(Interior_Model(ilayer).eta_variable(i,3),'%10.5e') ]);
            end
        else
            fprintf(FID, '%s\n', 'None');
        end
    end
    
    fprintf(FID, '%s\n', 'Complex Shear Modulus');
    for ilayer=2:Numerics.Nlayers
        if isfield(Interior_Model,'rheology_variable')==1
            fprintf(FID, '%s\n', 'Layer#      (n,m)         amplitude[\hat\mu_n^m/K_0^0]');
            for i=1:size(Interior_Model(ilayer).rheology_variable,1)
                fprintf(FID, '%s\n', [num2str(ilayer) '    (' num2str(Interior_Model(ilayer).rheology_variable(i,1)) ',' num2str(Interior_Model(ilayer).rheology_variable(i,2)) ')    '  num2str(Interior_Model(ilayer).rheology_variable(i,4),'%10.5e') ]);
            end
        else
            fprintf(FID, '%s\n', 'None');
        end
    end
    fprintf(FID, '%s\n', ' ');
    fprintf(FID, '%s\n', '----------- FORCING ----------');
    fprintf(FID, '%s\n', 'TIDAL POTENTIAL');
    fprintf(FID, '%s\n', 'Period [s]');
    fprintf(FID, '%s\n', num2str(Forcing.Td,'%10.5e'));
    fprintf(FID, '%s\n', '(n,m)');
    fprintf(FID, '%s\n', ['(' num2str(Forcing.n) ',' num2str(Forcing.m) ')']);
    fprintf(FID, '%s\n', ' ');
    fprintf(FID, '%s\n', '-----------  RESPONSE SPECTRUM ----------- ');
    for j=0:Numerics.perturbation_order
    index_order=find(Couplings.order==j);
    str_h=[];
    for k=1:length(index_order)
        str_h=[str_h '(' num2str(Couplings.n_s(index_order(k))) ',' num2str(Couplings.m_s(index_order(k))) '),   '];
    end
    fprintf(FID, '%s\n',[num2str(j) 'th Order Modes']);
    fprintf(FID, '%s\n',[num2str(length(index_order)) ' modes']);
    fprintf(FID, '%s\n',str_h);
    end
    fprintf(FID, '%s\n', '----------- NUMERICAL INFORMATION ----------');
    fprintf(FID, '%s\n', ['Number of Modes ' num2str(Nsol)]);
    fprintf(FID, '%s\n', ['Radial Points '  num2str(Numerics.Nr)]);
end
%% (3) PROPAGATE AND OBTAIN SOLUTION ------------------------------------------------------------
if verbose==1
    tStart = tic;
end

% Compute solution matrix
y_sol = get_solution(Interior_Model,Forcing,Numerics,Couplings,verbose);

if verbose==1
    disp(['Time Spent: ' num2str(toc(tStart)) 's'])
end
%% (4) PRINT SOME INFORMATION 
if verbose==1
    Nmodes=length(Couplings.n_s);
    disp('#####################################')
    cprintf('*black','---------- RESPONSE ----------------\n')
    disp('k Love numbers')
    disp('(n,m)           k_n^m')
    for i=1:Nmodes
        if Couplings.n_s(i)==Forcing.n && Couplings.m_s(i)==Forcing.m
            k2=y_sol(end,8,i)-1;
        else
            k2=y_sol(end,8,i);
        end
        disp(['(' num2str(Couplings.n_s(i)) ',' num2str(Couplings.m_s(i)) ')           '  num2str(k2,'%10.5e')   ])
    end
    disp('h Love numbers')
    disp('(n,m)           h_n^m')
    for i=1:Nmodes
        k2=-Interior_Model(end).gs*y_sol(end,2,i);
        disp(['(' num2str(Couplings.n_s(i)) ',' num2str(Couplings.m_s(i)) ')           '  num2str(k2,'%10.5e')   ])
    end
end
if out_file~=0
    Nmodes=length(Couplings.n_s);
    fprintf(FID, '%s\n','#####################################');
    fprintf(FID, '%s\n','---------- RESPONSE ----------------');
    fprintf(FID, '%s\n','k2 Love numbers');
    fprintf(FID, '%s\n','(n,m)           k_n^m');
    for i=1:Nmodes
        if Couplings.n_s(i)==Forcing.n && Couplings.m_s(i)==Forcing.m
            k2=y_sol(end,8,i)-1;
        else
            k2=y_sol(end,8,i);
        end
        fprintf(FID, '%s\n',['(' num2str(Couplings.n_s(i)) ',' num2str(Couplings.m_s(i)) ')           '  num2str(k2,'%10.5e')   ]);
    end
    if save_solution_vec == 1
        save(out_file_name_y,"y_sol");
    end
end
%% (5) Rearrange solution 
Nmodes=length(Couplings.n_s);
y_rad.y=y_sol; 
Love_Spectra.nf=Forcing.n;
Love_Spectra.mf=Forcing.m;
y_rad.nf=Forcing.n;
y_rad.mf=Forcing.m;
for i=1:Nmodes
    Love_Spectra.n(i)=Couplings.n_s(i);
    Love_Spectra.m(i)=Couplings.m_s(i);
    Love_Spectra.order(i)=Couplings.order(i);
    if Couplings.n_s(i)==Forcing.n && Couplings.m_s(i)==Forcing.m
        Love_Spectra.k(i)=y_sol(end,8,i)-1;
    else
        Love_Spectra.k(i)=y_sol(end,8,i);
    end
    Love_Spectra.h(i)=-Interior_Model(end).gs*y_sol(end,2,i);
    Love_Spectra.l(i)=-Interior_Model(end).gs*y_sol(end,3,i);
    y_rad.n(i)=Couplings.n_s(i);
    y_rad.m(i)=Couplings.m_s(i);
end

end
