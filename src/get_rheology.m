%% Description 
% Computes the complex rheology of the body based on either percentage
% variations of the average rheology or full, real rheology fields. Also
% contains the option to run using legacy values in order to compare
% against previous results. 
% 
% -  It first normalizes the input values. 
% -  Then (potentially) converts lateral rheology variations based on
%    percentages into SPH.
% -  It then converts the SPH, either from percentage based variations or
%    real rheology fields, into a lat-lon field.
% -  Using the lat-lon it computes the complex rheology in the Fourier
%    domain and filters the relevant modes based on relative magnitude. 
%% Variables 
% The functions takes Interior_Model and updates it with some fields required by get_love
% Interior_Model: Structure containing the interior model information
        % Input 
            % Mean properties: 
            %Interior_Model(ilayer).R0: radius
            %Interior_Model(ilayer).rho0: density        
            %Interior_Model(ilayer).mu0: shear modulus
            %Interior_Model(ilayer).Ks0: bulk modulus, if not given, the model is assumed incompressible, 
            %Interior_Model(ilayer).eta0: viscosity, if not give, the body is assumed elastic
            % Interior_Model(ilayer).MaxTime: normalized Maxwell time, it can be given instead of the viscosity, else it is computed 
            %Interior_Model(ilayer).Gg0: gravitational constant (should be equal for all layers)
        % Lateral variations 
        % Lateral variations can be provided in three different formats
            %%% (1) in complex spherical harmonics: 
                %Interio_Model(ilayer).mu_variable: shear modulus variations
                    %mu_variable(:,1): degree of variation 
                    %mu_variable(:,2): order of variation 
                    %mu_variable(:,3): amplitude of the variation (mu_l^m/mu^0_0)
                %Interio_Model(ilayer).K_variable: bulk modulus variations 
                    %K_variable(:,1): degree of variation 
                    %K_variable(:,2): order of variation 
                    %K_variable(:,3):  amplitude of bulk modulus variations (K_l^m/K^0_0)
                %Interio_Model(ilayer).eta_variable: viscosity
                    %eta_variable(:,1): degree of variation 
                    %eta_variable(:,2): order of variation 
                    %eta_variable(:,3):  amplitude of viscosity variations (eta_l^m/eta^0_0)
            %%% (2) in peak to peak variation amplitude wrt to the mean value (in percent)
                    %Interio_Model(ilayer).mu_variable_p2p: shear modulus variations
                    %mu_variable_p2p(:,1): degree of variation 
                    %mu_variable_p2p(:,2): order of variation 
                    %mu_variable_p2p:,3): amplitude of the variation (mu_l^m/mu^0_0)
                %Interio_Model(ilayer).K_variable_p2p: bulk modulus variations 
                    %K_variable_p2p(:,1): degree of variation 
                    %K_variable_p2p(:,2): order of variation 
                    %K_variable_p2p(:,3):  amplitude of bulk modulus variations (K_l^m/K^0_0)
                %Interio_Model(ilayer).eta_variable: viscosity
                    %eta_variable_p2p(:,1): degree of variation 
                    %eta_variable_p2p(:,2): order of variation 
                    %eta_variable_p2p(:,3):  amplitude of viscosity variations (eta_l^m/eta^0_0)  
            %%% (3) as a map, in which case get_rheology will transform it to
            % a spherical harmonics expansion. The maps can be generated by generated SPH_LatLon in SPH_Tools and 
            % for efficient transformation should be evaluated in the lat lon grid specified there, 
            % which depends on the maximum degree of the expansion. 
            % IMPORTANT NOTICE: The map(s) should already be scaled by their relevant average value 
            % (Interior_Model(ilayer).eta0, Interior_Model(ilayer).mu0 or Interior_Model(ilayer).Ks0) as: 
                    % Interior_Model(ilayer).mu_latlon/Interior_Model(ilayer).mu0
                    % Interior_Model(ilayer).eta_latlon/Interior_Model(ilayer).eta0
                    % Interior_Model(ilayer).K_latlon/Interior_Model(ilayer).Ks0
            % This ensures that the maps that you input have a mean of 1, which is what
            % the code expects, and that the actual fields have an average equal
            % to the prescribed average (Interior_Model(ilayer).XXX0)
            % Each of the input fields has the components 
                    %.lon:  longitude [IN DEGREES]
                    %.lat:  latitude [IN DEGREES]
                    %.z:    pxq grid where p stands for latitude and q for
                    %.lmax: maximum harmonic degree
            % for both (1) and (2) the expansion in spherical harmonics should result in 
            % a real field (there should be both m>0 and m<0 components)
            % If this is not the case the and only >0 components are provided, the <0 component is computed
       
         % Assigned in get_rheology 
            %%% Mean properties: 
            % Interior_Model(ilayer).R: normalized radius (normalized with Interior_Model(end).R0)
            % Interior_Model(ilayer).rho: normalized density  (normalized with Interior_Model(end).rho0)     
            % Interior_Model(ilayer).mu: normalized shear modulus of the layer (normalized with Interior_Model(end).mu0)
            % Interior_Model(ilayer).Ks: normalized bulk modulus of layer (normalized with Interior_Model(end).mu0)
            % Interior_Model(ilayer).Ks: normalized viscosity of layer (normalized with Interior_Model(end).mu0*Forcing.T)
            % Interior_Model(ilayer).Gg: normalized gravitational constant (can also be given by user in model given in non-dimensional units)
            % Interior_Model(ilayer).gs: normalized gravity at Interior_Model(ilayer).R0
            % Interior_Model(ilayer).gs0: gravity at Interior_Model(ilayer).R0
            % Interior_Model(ilayer).muC: normalized complex shear modulus 
            % Interior_Model(ilayer).mu00R: normalized real component of the shear modulus 
            % Interior_Model(ilayer).rho0_av: averaged denseity at Interior_Model(ilayer).R0
            % Interior_Model(ilayer).rho_av: normalized averaged denseity at Interior_Model(ilayer).R0
            %%% Lateral variations:
            % Interior_Model(ilayer).rheology_variable: rheology variable (assigned inside the code)
            % rheology_variable(:,1): degree of variation 
            % rheology_variable(:,2): order of variation 
            % rheology_variable(:,3): amplitude of bulk modulus variations (K_l^m/K^0_0)  
            % rheology_variable(:,4): amplitude of complex shear modulus variations (mu_l^m/mu^0_0)
            %%% Useful properties, only computed for later storage: 
            % Interior_Model(ilayer).mu_latlon_set_internal: map of the shear modulus perturbations when provided as format (1) or (2), set internally
            % Interior_Model(ilayer).eta_latlon_set_internal: map of the viscosity perturbations when provided as format (1) or (2), set internally
            % Interior_Model(ilayer).mu_stokes_set_internal: spectral decomposition of the provided shear modulus map, only computed with a map as input
            % Interior_Model(ilayer).eta_stokes_set_internal: spectral decomposition of the provided viscosity map, only computed with a map as input   

        % ilayer=1 corresponds to the core, which in case of an icy moon, includes both the solid and liquid later. 
        % for ilayer=1, the shear and bulk modulus are not required
%% 
function [Interior_Model] = get_rheology(Interior_Model,Numerics,Forcing,varargin)
G=6.67430E-11;
plot_rheology_spectra=0; 
calculate_G = true;
verbose=0; 
out_file=0; 

% Determines whether sin components are taken into account when expanding 
% the rheology into the fourier domain. Default is 1.
sine_component_factor = 1; % 0 or 1 
%% (0) Optional Inputs Defaults -----------------------------------------------------
if isfield(Numerics,'Nr')==0
    Numerics.Nr=100;
end
if isfield(Numerics,'rheology_cutoff')==0
    Numerics.rheology_cutoff=2;
end
if isfield(Numerics,'minimum_rheology_value')==0
    % If a full rheology field is given as input the highest rheology mode must be large
    % enough to not crash due to numerical noise imitating rheology modes.
    Numerics.minimum_rheology_value=-14;
end
if isfield(Numerics,'load_couplings')==0
    Numerics.load_couplings=1;
end
if isfield(Numerics,'perturbation_order')==0
    Numerics.perturbation_orders=2;
end
if isfield(Numerics,'solution_cutoff')==0
    Numerics.perturbation_orders=0;
    Numerics.solution_cutoff=8;
end

for k = 1:length(varargin)
    if strcmpi(varargin{k},'plot_rheology_spectra')
        plot_rheology_spectra=varargin{k+1}; 
        varargin{k+1}=[]; 
        varargin{k}=[];
    end
    if strcmpi(varargin{k},'verbose')
        verbose=1; 
        varargin{k}=[];
    end
    if strcmpi(varargin{k},'out_file')
        out_file=varargin{k+1}; 
        varargin{k+1}=[]; 
        varargin{k}=[];
    end
    if strcmpi(varargin{k},'save_location')
        save_location=varargin{k+1}; 
        varargin{k+1}=[]; 
        varargin{k}=[];
    end
    if strcmpi(varargin{k},'calculate_G')
        calculate_G=varargin{k+1}; 
        varargin{k+1}=[]; 
        varargin{k}=[];
    end
    if strcmpi(varargin{k},'include_sine')
        sine_component_factor=varargin{k+1}; 
        varargin{k+1}=[]; 
        varargin{k}=[];
    end
end

% Degree determining the spatial resolution of the rheology map in
% SPH_LatLon, higher is better but slower. 
l_max_base_value = 30; % Base/Reference value that is set

% Since l_max can vary between layers it is initially set to the base value
l_max = l_max_base_value;

%% (0) READ THE INPUT AND Nondimensional ------------------------------------------------------------------
% Non-dimensionalize the parameters based on the values in the outer layer
% Puts the input in the format required for the code. 

% If calculate_G=false a legacy version of the code is used
if calculate_G && isfield(Interior_Model(end),"Gg") == 0
    Gg = G*(Interior_Model(end).R0*1000)^2*Interior_Model(end).rho0^2/Interior_Model(end).mu0;
elseif isfield(Interior_Model(end),"Gg")==1  % If the normalized gravitational constant is already provided, use that
    Gg = Interior_Model(end).Gg; 
else
    % Test values for Gg, Legacy values (only used when comparing against old data)
    r_ratio = 0.53;
    rho_r = 1.59;
    mu_eff = 5.2;
    rho_av = rho_r*r_ratio^3+(1-r_ratio^3);
    Gg = 3/(4*pi)/mu_eff/rho_av^2;
end

% check input for layers, create inputs not provided by the user and nondimensionalize
% Initialize fields if not provided by the user 
if isfield(Interior_Model(1),"MaxTime")==0
    Interior_Model(1).MaxTime=[];
end
if isfield(Interior_Model(1),"eta0")==0
    Interior_Model(1).eta0=[];
end
if isfield(Interior_Model(1),"Ks0")==0
    Interior_Model(1).Ks0=[];
end
if isfield(Interior_Model(1),"mu_variable")==0
    Interior_Model(1).mu_variable=[];
end
if isfield(Interior_Model(1),"eta_variable")==0
    Interior_Model(1).eta_variable=[];
end
if isfield(Interior_Model(1),"K_variable")==0
    Interior_Model(1).K_variable=[];
end
if isfield(Interior_Model(1),"mu_variable_p2p")==0
    Interior_Model(1).mu_variable_p2p=[];
end
if isfield(Interior_Model(1),"eta_variable_p2p")==0
    Interior_Model(1).eta_variable_p2p=[];
end
if isfield(Interior_Model(1),"K_variable_p2p")==0
    Interior_Model(1).K_variable_p2p=[];
end
if isfield(Interior_Model(1),"mu_latlon")==0
    Interior_Model(1).mu_latlon=[];
else
    % Check for a correct mean of ~1 for the map
    for ilayer=2:Numerics.Nlayers
        if ~isempty(Interior_Model(ilayer).mu_latlon)
            % Compute the average value
            temp_mean = mean2(Interior_Model(ilayer).mu_latlon.z .* ...
                              sin(Interior_Model(ilayer).mu_latlon.lat*pi/180 + pi/2) * pi/2);
            if abs(temp_mean - 1) > 1e-3 && temp_mean > 1e-3
                error(['ERROR. \nInput map of the shear modulus in layer ' num2str(ilayer) ' has an average of not ~1'])
            end
        end
    end
end
if isfield(Interior_Model(1),"eta_latlon")==0
    Interior_Model(1).eta_latlon=[];
    % Check for a correct mean of ~1 for the map
    for ilayer=2:Numerics.Nlayers
        if ~isempty(Interior_Model(ilayer).eta_latlon)
            % Compute the average value
            temp_mean = mean2(Interior_Model(ilayer).eta_latlon.z .* ...
                              sin(Interior_Model(ilayer).eta_latlon.lat*pi/180 + pi/2) * pi/2);
            if abs(temp_mean - 1) > 1e-3 && temp_mean > 1e-3
                error(['ERROR. \nInput map of the viscosity in layer ' num2str(ilayer) ' has an average of not ~1'])
            end
        end
    end
end
if isfield(Interior_Model(1),"K_latlon")==0
    Interior_Model(1).K_latlon=[];
    % Check for a correct mean of ~1 for the map
    for ilayer=2:Numerics.Nlayers
        if ~isempty(Interior_Model(ilayer).K_latlon)
            % Compute the average value
            temp_mean = mean2(Interior_Model(ilayer).K_latlon.z .* ...
                              sin(Interior_Model(ilayer).K_latlon.lat*pi/180 + pi/2) * pi/2);
            if abs(temp_mean - 1) > 1e-3 && temp_mean > 1e-3
                error(['ERROR. \nInput map of the bulk modulus in layer ' num2str(ilayer) ' has an average of not ~1'])
            end
        end
    end
end

% First non-dimensionalize the values
for ilayer=1:Numerics.Nlayers
    if ilayer==1 %layer 1
        Interior_Model(ilayer).R = Interior_Model(ilayer).R0/Interior_Model(end).R0;
        Interior_Model(ilayer).rho = Interior_Model(ilayer).rho0/Interior_Model(end).rho0; 

        % Check whether a dimensional delta rho between the core and the second layer is provided
        if isfield(Interior_Model(ilayer),"Delta_rho0")==0
            Interior_Model(ilayer).Delta_rho0= (Interior_Model(1).rho0-Interior_Model(2).rho0);
            % Else the Delta_rho0 is provided by the user 
        end
        Interior_Model(ilayer).Delta_rho = Interior_Model(ilayer).Delta_rho0/Interior_Model(end).rho0;
        Interior_Model(ilayer).Gg0 = G; % G
        Interior_Model(ilayer).Gg  = Gg; % Non-dimensionalised G  
        % Build the (normalized) average density of the body and compute the gravitational acceleration
        M  = 4/3*pi*Interior_Model(ilayer).rho*Interior_Model(ilayer).R^3;
        M0 = 4/3*pi*Interior_Model(ilayer).rho0*Interior_Model(ilayer).R0^3; 
        Interior_Model(ilayer).rho_av0 = M0/(4/3*pi*Interior_Model(ilayer).R0^3);
        Interior_Model(ilayer).rho_av = M/(4/3*pi*Interior_Model(ilayer).R^3);
        Interior_Model(ilayer).gs0 = Interior_Model(ilayer).Gg0*M0/(Interior_Model(ilayer).R0^2)*1e3; %1e3 bc radius is in km
        Interior_Model(ilayer).gs = Interior_Model(ilayer).Gg*M/(Interior_Model(ilayer).R^2);
    else
        %non-dimensionalise 
        Interior_Model(ilayer).R = Interior_Model(ilayer).R0/Interior_Model(end).R0;
        Interior_Model(ilayer).rho = Interior_Model(ilayer).rho0/Interior_Model(end).rho0;
        Interior_Model(ilayer).mu = Interior_Model(ilayer).mu0/Interior_Model(end).mu0;        
        % check if the layer is viscous
        if ~isempty(Interior_Model(ilayer).MaxTime)
                Interior_Model(ilayer).eta0 = Interior_Model(ilayer).MaxTime/(2*pi);
                Interior_Model(ilayer).eta = Interior_Model(ilayer).MaxTime/(2*pi);
                Interior_Model(ilayer).elastic = 0;
        elseif ~isempty(Interior_Model(ilayer).eta0) 
            % 1\omega is used to non-dimensionalize time
            Interior_Model(ilayer).eta = Interior_Model(ilayer).eta0/(Interior_Model(end).mu0*Forcing(1).Td);
            Interior_Model(ilayer).MaxTime = 2*pi*Interior_Model(ilayer).eta0/Interior_Model(ilayer).mu0/Forcing(1).Td;
            Interior_Model(ilayer).elastic = 0;
        else %the layer is elastic
            cprintf([1,0.5,0],['Viscosity for layer ' num2str(ilayer) ' not provided, I will assume the layer is elastic \n'])
            Interior_Model(ilayer).eta = NaN;
            Interior_Model(ilayer).MaxTime = NaN; 
            Interior_Model(ilayer).elastic = 1;
        end
        % Check if the layer is incompressible 
        if ~isempty(Interior_Model(ilayer).Ks0)
            Interior_Model(ilayer).Ks = Interior_Model(ilayer).Ks0/Interior_Model(end).mu0;
        else
            cprintf([1,0.5,0],['Bulk modulus for layer ' num2str(ilayer) ' not provided, I will assume the layer is incompressible \n'])
            Interior_Model(ilayer).Ks0=1e5*Interior_Model(end).mu0;
            Interior_Model(ilayer).Ks = Interior_Model(ilayer).Ks0/Interior_Model(end).mu0;
        end
        % check if this is an ocean layer 
        if isfield(Interior_Model,'ocean')
            if Interior_Model(ilayer).ocean==1
                cprintf('cyan',['Layer ' num2str(ilayer) ' is an ocean layer \n'])
            end
        end
        Interior_Model(ilayer).Gg0 = G; % G
        Interior_Model(ilayer).Gg  = Gg; % Non-dimensionalised G
        % Density difference with layer below taken such that it should be positive
        Interior_Model(ilayer).Delta_rho = Interior_Model(ilayer-1).rho-Interior_Model(ilayer).rho; 
        % Add mass of the layer to obtain the (normalized) average density
        M0 = M0 + 4/3*pi*Interior_Model(ilayer).rho0*(Interior_Model(ilayer).R0^3-Interior_Model(ilayer-1).R0^3);
        M  = M + 4/3*pi*Interior_Model(ilayer).rho*(Interior_Model(ilayer).R^3-Interior_Model(ilayer-1).R^3);
        Interior_Model(ilayer).rho_av0 = M0/(4/3*pi*Interior_Model(ilayer).R0^3);
        Interior_Model(ilayer).rho_av  = M/(4/3*pi*Interior_Model(ilayer).R^3);
        Interior_Model(ilayer).gs0 = Interior_Model(ilayer).Gg0*M0/(Interior_Model(ilayer).R0^2)*1e3; %1e3 bc radius is in km
        Interior_Model(ilayer).gs = Interior_Model(ilayer).Gg*M/(Interior_Model(ilayer).R^2);

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%%%%%%%% LATERAL VARIATIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % check if there are lateral variations and set them in the right format

        % Lateral variations given in complex spherical harmonics ---------
        if  (~isempty(Interior_Model(ilayer).mu_variable) && max(abs(Interior_Model(ilayer).mu_variable(:,3)))>0) || ...
            (~isempty(Interior_Model(ilayer).eta_variable) && max(abs(Interior_Model(ilayer).eta_variable(:,3)))>0) || ...
            (~isempty(Interior_Model(ilayer).K_variable) && max(abs(Interior_Model(ilayer).K_variable(:,3)))>0)
            % lateral variations provided in complex spherical harmonics 
            % check that all fields are provided, identify degrees and orders of all lateral variations, 
            % make sure the resulting fields are real
            Interior_Model(ilayer).uniform=0; 
            nR=[];
            mR=[]; 
            if ~isempty(Interior_Model(ilayer).mu_variable)
                nR=[nR; Interior_Model(ilayer).mu_variable(:,1)];
                mR=[mR; Interior_Model(ilayer).mu_variable(:,2)];
            end
            if ~isempty(Interior_Model(ilayer).eta_variable)
                nR=[nR; Interior_Model(ilayer).eta_variable(:,1)];
                mR=[mR; Interior_Model(ilayer).eta_variable(:,2)];
            end
            if ~isempty(Interior_Model(ilayer).K_variable)
                nR=[nR; Interior_Model(ilayer).K_variable(:,1)];
                mR=[mR; Interior_Model(ilayer).K_variable(:,2)];
            end

            % get the unique combinations
            C = unique([nR mR],'rows');
            nR=C(:,1);
            mR=C(:,2);
            %loop over all degrees and orders to check fields are real & put structure in the right format 
            for i=1:length(nR)
                if ~isempty(Interior_Model(ilayer).mu_variable)
                    indP_mu=find(nR(i)==Interior_Model(ilayer).mu_variable(:,1) & mR(i)==Interior_Model(ilayer).mu_variable(:,2));
                else
                    indP_mu=[];
                end
                if ~isempty(Interior_Model(ilayer).eta_variable)
                    indP_eta=find(nR(i)==Interior_Model(ilayer).eta_variable(:,1) & mR(i)==Interior_Model(ilayer).eta_variable(:,2));
                else
                    indP_eta=[];
                end
                if ~isempty(Interior_Model(ilayer).K_variable)
                    indP_K=find(nR(i)==Interior_Model(ilayer).K_variable(:,1) & mR(i)==Interior_Model(ilayer).K_variable(:,2));
                else
                    indP_K=[];
                end
                if isempty(indP_mu)
                    Interior_Model(ilayer).mu_variable(end+1,1)=nR(i); 
                    Interior_Model(ilayer).mu_variable(end,2)=mR(i); 
                    Interior_Model(ilayer).mu_variable(end,3)=0; 
                end
                if isempty(indP_eta)
                    Interior_Model(ilayer).eta_variable(end+1,1)=nR(i); 
                    Interior_Model(ilayer).eta_variable(end,2)=mR(i); 
                    Interior_Model(ilayer).eta_variable(end,3)=0; 
                end
                if isempty(indP_K)
                    Interior_Model(ilayer).K_variable(end+1,1)=nR(i); 
                    Interior_Model(ilayer).K_variable(end,2)=mR(i); 
                    Interior_Model(ilayer).K_variable(end,3)=0; 
                end
                ind=find(mR==-mR(i)); 
                if isempty(ind)==1
                    cprintf([1,0.5,0],"Be careful! Lateral variations field is not real, I will add a -m component to make it real. \n")
                    % shear modulus 
                    Interior_Model(ilayer).mu_variable(end+1,1)=nR(i); 
                    Interior_Model(ilayer).mu_variable(end+1,2)=-mR(i); 
                    Interior_Model(ilayer).mu_variable(end+1,3)=(-1)^mR(i)*conj(Interior_Model(ilayer).mu_variable(i,3)); 
                    % bulk modulus 
                    Interior_Model(ilayer).K_variable(end+1,1)=nR(i); 
                    Interior_Model(ilayer).K_variable(end+1,2)=-mR(i); 
                    Interior_Model(ilayer).K_variable(end+1,3)=(-1)^mR(i)*conj(Interior_Model(ilayer).K_variable(i,3)); 
                    %viscosity 
                    Interior_Model(ilayer).eta_variable(end+1,1)=nR(i); 
                    Interior_Model(ilayer).eta_variable(end+1,2)=-mR(i); 
                    Interior_Model(ilayer).eta_variable(end+1,3)=(-1)^mR(i)*conj(Interior_Model(ilayer).eta_variable(i,3)); 
                end
            end

        % lateral variations provided in peak to peak variations -----------  
        elseif (~isempty(Interior_Model(ilayer).mu_variable_p2p) && max(abs(Interior_Model(ilayer).mu_variable_p2p(:,3)))>0) || ...
               (~isempty(Interior_Model(ilayer).eta_variable_p2p) && max(abs(Interior_Model(ilayer).eta_variable_p2p(:,3)))>0) || ...
               (~isempty(Interior_Model(ilayer).K_variable_p2p) && max(abs(Interior_Model(ilayer).K_variable_p2p(:,3)))>0)
            % check that all fields are provided, identify degrees and orders of all lateral variations, 
            % write lateral variations in terms of complex SH
            Interior_Model(ilayer).uniform=0;
            nR=[];
            mR=[]; 
            if ~isempty(Interior_Model(ilayer).mu_variable_p2p)
                nR=[nR; Interior_Model(ilayer).mu_variable_p2p(:,1)];
                mR=[mR; Interior_Model(ilayer).mu_variable_p2p(:,2)];
            end
            if ~isempty(Interior_Model(ilayer).eta_variable_p2p)
                nR=[nR; Interior_Model(ilayer).eta_variable_p2p(:,1)];
                mR=[mR; Interior_Model(ilayer).eta_variable_p2p(:,2)];
            end
            if ~isempty(Interior_Model(ilayer).K_variable_p2p)
                nR=[nR; Interior_Model(ilayer).K_variable_p2p(:,1)];
                mR=[mR; Interior_Model(ilayer).K_variable_p2p(:,2)];
            end
            
            % get the unique combinations
            C = unique([nR mR],'rows');
            nR=C(:,1);
            mR=C(:,2);
            
            %loop over all degrees to make sure the structure have the right shape
            for i=1:length(nR)
                if ~isempty(Interior_Model(ilayer).mu_variable_p2p)
                    indP_mu=find(nR(i)==Interior_Model(ilayer).mu_variable_p2p(:,1) & ...
                                 mR(i)==Interior_Model(ilayer).mu_variable_p2p(:,2));
                else
                    indP_mu = [];
                end
                if ~isempty(Interior_Model(ilayer).eta_variable_p2p)
                    indP_eta=find(nR(i)==Interior_Model(ilayer).eta_variable_p2p(:,1) & ...
                                  mR(i)==Interior_Model(ilayer).eta_variable_p2p(:,2));
                else
                    indP_eta = [];
                end
                if ~isempty(Interior_Model(ilayer).K_variable_p2p)
                    indP_K=find(nR(i)==Interior_Model(ilayer).K_variable_p2p(:,1) & ...
                                mR(i)==Interior_Model(ilayer).K_variable_p2p(:,2));
                else
                    indP_K = [];
                end
                if isempty(indP_mu)
                    Interior_Model(ilayer).mu_variable_p2p(end+1,1)=nR(i); 
                    Interior_Model(ilayer).mu_variable_p2p(end,2)=mR(i); 
                    Interior_Model(ilayer).mu_variable_p2p(end,3)=0; 
                end
                if isempty(indP_eta)
                    Interior_Model(ilayer).eta_variable_p2p(end+1,1)=nR(i); 
                    Interior_Model(ilayer).eta_variable_p2p(end,2)=mR(i); 
                    Interior_Model(ilayer).eta_variable_p2p(end,3)=0; 
                end
                if isempty(indP_K)
                    Interior_Model(ilayer).K_variable_p2p(end+1,1)=nR(i); 
                    Interior_Model(ilayer).K_variable_p2p(end,2)=mR(i); 
                    Interior_Model(ilayer).K_variable_p2p(end,3)=0; 
                end
            end
            
            % convert to complex spherical harmonics 
            Interior_Model(ilayer).eta_variable=[];
            Interior_Model(ilayer).mu_variable=[];
            Interior_Model(ilayer).K_variable=[];
            for i=1:length(nR)
                nR_fixed=nR(i);
                mR_fixed=mR(i);
                % get peak to peak variations
                Ynm_stokes.clm=zeros(2*l_max,2*l_max);
                Ynm_stokes.slm=zeros(2*l_max,2*l_max);
                Ynm_stokes.lmax=2*l_max-1;
                Ynm_stokes.clm(nR(i)+1,mR(i)+1)=1;
                [Ynm_zlonlat] = SPH_LatLon(Ynm_stokes);
                Ynm_z = Ynm_zlonlat.z;
                Delta = max(Ynm_z(:))-min(Ynm_z(:));
                % convert to complex spherical harmonics 
                if mR_fixed==0
                    % shear modulus 
                    Interior_Model(ilayer).mu_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).mu_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).mu_variable(end,3)=Interior_Model(ilayer).mu_variable_p2p(i,3)/100/Delta;
                    % bulk modulus
                    Interior_Model(ilayer).K_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).K_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).K_variable(end,3)=Interior_Model(ilayer).K_variable_p2p(i,3)/100/Delta;
                    %viscosity 
                    Interior_Model(ilayer).eta_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).eta_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).eta_variable(end,3)=Interior_Model(ilayer).eta_variable_p2p(i,3)/100/Delta;
                elseif mR_fixed>0
                    % shear modulus 
                    Interior_Model(ilayer).mu_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).mu_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).mu_variable(end,3)=sqrt(2)/2*Interior_Model(ilayer).mu_variable_p2p(i,3)/100/Delta;
                    Interior_Model(ilayer).mu_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).mu_variable(end,2)=-mR_fixed;
                    Interior_Model(ilayer).mu_variable(end,3)=(-1)^mR_fixed*sqrt(2)/2*Interior_Model(ilayer).mu_variable_p2p(i,3)/100/Delta;
                    % bulk modulus
                    Interior_Model(ilayer).K_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).K_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).K_variable(end,3)=sqrt(2)/2*Interior_Model(ilayer).K_variable_p2p(i,3)/100/Delta;
                    Interior_Model(ilayer).K_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).K_variable(end,2)=-mR_fixed;
                    Interior_Model(ilayer).K_variable(end,3)=(-1)^mR_fixed*sqrt(2)/2*Interior_Model(ilayer).K_variable_p2p(i,3)/100/Delta;
                    % viscosity 
                    Interior_Model(ilayer).eta_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).eta_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).eta_variable(end,3)=sqrt(2)/2*Interior_Model(ilayer).eta_variable_p2p(i,3)/100/Delta;
                    Interior_Model(ilayer).eta_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).eta_variable(end,2)=-mR_fixed;
                    Interior_Model(ilayer).eta_variable(end,3)=(-1)^mR_fixed*sqrt(2)/2*Interior_Model(ilayer).eta_variable_p2p(i,3)/100/Delta;
                else
                    % shear modulus 
                    Interior_Model(ilayer).mu_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).mu_variable(end,2)=-mR_fixed;
                    Interior_Model(ilayer).mu_variable(end,3)=-1i*(-1)^mR_fixed*sqrt(2)/2*Interior_Model(ilayer).mu_variable_p2p(i,3)/100/Delta;
                    Interior_Model(ilayer).mu_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).mu_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).mu_variable(end,3)=1i*sqrt(2)/2*Interior_Model(ilayer).mu_variable_p2p(i,3)/100/Delta;
                    % bulk modulus
                    Interior_Model(ilayer).K_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).K_variable(end,2)=-mR_fixed;
                    Interior_Model(ilayer).K_variable(end,3)=-1i*(-1)^mR_fixed*sqrt(2)/2*Interior_Model(ilayer).K_variable_p2p(i,3)/100/Delta;
                    Interior_Model(ilayer).K_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).K_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).K_variable(end,3)=1i*sqrt(2)/2*Interior_Model(ilayer).K_variable_p2p(i,3)/100/Delta;
                    % viscosity 
                    Interior_Model(ilayer).eta_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).eta_variable(end,2)=-mR_fixed;
                    Interior_Model(ilayer).eta_variable(end,3)=-1i*(-1)^mR_fixed*sqrt(2)/2*Interior_Model(ilayer).eta_variable_p2p(i,3)/100/Delta;
                    Interior_Model(ilayer).eta_variable(end+1,1)=nR_fixed;
                    Interior_Model(ilayer).eta_variable(end,2)=mR_fixed;
                    Interior_Model(ilayer).eta_variable(end,3)=1i*sqrt(2)/2*Interior_Model(ilayer).eta_variable_p2p(i,3)/100/Delta;
                end
            end

        % lateral variations provided as a map ----------------------------
        elseif ~isempty(Interior_Model(ilayer).mu_latlon) || ~isempty(Interior_Model(ilayer).eta_latlon) || ...
               ~isempty(Interior_Model(ilayer).K_latlon)
            % Compute the complex spherical harmonics when the rheology is
            % provided as a map on a lat-lon grid
            Interior_Model(ilayer).uniform=0;
            if isempty(Interior_Model(ilayer).mu_latlon)
                if isempty(Interior_Model(ilayer).eta_latlon)
                    Interior_Model(ilayer).mu_latlon=Interior_Model(ilayer).K_latlon; 
                    Interior_Model(ilayer).mu_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).mu;
                    Interior_Model(ilayer).eta_latlon=Interior_Model(ilayer).K_latlon; 
                    Interior_Model(ilayer).eta_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).eta;
                else
                    Interior_Model(ilayer).mu_latlon=Interior_Model(ilayer).eta_latlon; 
                    Interior_Model(ilayer).mu_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).mu;
                end
            end
            if isempty(Interior_Model(ilayer).eta_latlon)
                if isempty(Interior_Model(ilayer).mu_latlon)
                    Interior_Model(ilayer).eta_latlon=Interior_Model(ilayer).K_latlon; 
                    Interior_Model(ilayer).eta_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).eta;
                    Interior_Model(ilayer).mu_latlon=Interior_Model(ilayer).K_latlon; 
                    Interior_Model(ilayer).mu_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).mu;
                else
                    Interior_Model(ilayer).eta_latlon=Interior_Model(ilayer).mu_latlon; 
                    Interior_Model(ilayer).eta_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).eta;
                end
            end
            if isempty(Interior_Model(ilayer).K_latlon)
                if isempty(Interior_Model(ilayer).mu_latlon)
                    Interior_Model(ilayer).K_latlon=Interior_Model(ilayer).eta_latlon; 
                    Interior_Model(ilayer).K_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).Ks;
                    Interior_Model(ilayer).mu_latlon=Interior_Model(ilayer).eta_latlon; 
                    Interior_Model(ilayer).mu_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).mu;
                else
                    Interior_Model(ilayer).K_latlon=Interior_Model(ilayer).mu_latlon; 
                    Interior_Model(ilayer).K_latlon.z=ones(size(Interior_Model(ilayer).mu_latlon.z))*Interior_Model(ilayer).Ks;
                end
            end

        % No lateral variations provided so the layer is assumed to be
        % spherically-symmetric
        else
            cprintf([1,0.5,0],['No lateral variations provided for layer ' num2str(ilayer) ', I will assume the layer is spherically-symmetric \n'])
            Interior_Model(ilayer).eta_variable=[0 0 0]; 
            Interior_Model(ilayer).mu_variable=[0 0 0]; 
            Interior_Model(ilayer).K_variable=[0 0 0]; 
            Interior_Model(ilayer).uniform=1;
        end
    end
end

%% GET RHEOLOGY ------------------------------------------------------------------
% here the rheology is obtained is transformed to the Fourier domain by 
% obtaining the spatailly dependant complex shear modulus
% converting it to spherical harmonics
% cutting up the expansion into spherical harmonics 

% Construct the viscosity and shear modulus in the fourier domain
for ilayer=2:Numerics.Nlayers
    % If there is a direct insertion of a lat-lon grid, that lmax value is used. 
    % If a legacy version of the code is used the lmax is set to 25 for this part
    if ~isempty(Interior_Model(ilayer).mu_latlon)
        l_max = (Interior_Model(ilayer).mu_latlon.lmax + 1)/2;
    elseif ~calculate_G
        l_max = 25;
    else
        l_max = l_max_base_value;
    end
    if Interior_Model(ilayer).elastic==0 % viscoelastic model
        if Interior_Model(ilayer).uniform==0 % lateral variations
            %%%%%%%%%% build mu %%%%%%%%%%
            % Check whether direct insertion of a lat-lon grid is used
            if ~isempty(Interior_Model(ilayer).mu_latlon)
                [mu_zlonlat] = Interior_Model(ilayer).mu_latlon;

                % Do a spectral decomposition of the shear modulus map for storage purposes
                [temp_mu_stokes] = LatLon_SPH(mu_zlonlat);
                Interior_Model(ilayer).mu_stokes_set_internal = temp_mu_stokes;
            else
                mu_stokes.clm=zeros(2*l_max,2*l_max);
                mu_stokes.slm=zeros(2*l_max,2*l_max);
                mu_stokes.lmax=2*l_max-1;
                for i=1:size(Interior_Model(ilayer).mu_variable,1)
                    % Convert to real spherical harmonics
                    if Interior_Model(ilayer).mu_variable(i,2)>0
                        nR=Interior_Model(ilayer).mu_variable(i,1);
                        mR=Interior_Model(ilayer).mu_variable(i,2);
                        mu_stokes.clm(nR+1,mR+1)=sqrt(2)*real(Interior_Model(ilayer).mu_variable(i,3));
                        mu_stokes.slm(nR+1,mR+1)=-sqrt(2)*imag(Interior_Model(ilayer).mu_variable(i,3));
                    elseif Interior_Model(ilayer).mu_variable(i,2)<0               
                    else
                        nR=Interior_Model(ilayer).mu_variable(i,1);
                        mR=Interior_Model(ilayer).mu_variable(i,2);
                        amplitude=Interior_Model(ilayer).mu_variable(i,3);
                        mu_stokes.clm(nR+1,mR+1)=amplitude;
                    end     
                end
                
                % Convert to a lat-lon grid
                [mu_zlonlat] = SPH_LatLon(mu_stokes);

                % Save the lat-lon grid as mu_latlon_set_internal
                Interior_Model(ilayer).mu_latlon_set_internal = mu_zlonlat;
            end

            %%%%%%%%%% build eta %%%%%%%%%%
            % Check whether direct insertion of a lat-lon grid is used
            if ~isempty(Interior_Model(ilayer).eta_latlon)
                [eta_zlonlat] = Interior_Model(ilayer).eta_latlon;

                % Do a spectral decomposition of the viscosity map for storage purposes
                [temp_eta_stokes] = LatLon_SPH(eta_zlonlat);
                Interior_Model(ilayer).eta_stokes_set_internal = temp_eta_stokes;
            else
                eta_stokes.clm=zeros(2*l_max,2*l_max);
                eta_stokes.slm=zeros(2*l_max,2*l_max);
                eta_stokes.lmax=2*l_max-1;
                for i=1:size(Interior_Model(ilayer).eta_variable,1)
                    % Convert to real spherical harmonics
                    if Interior_Model(ilayer).eta_variable(i,2)>0
                        nR=Interior_Model(ilayer).eta_variable(i,1);
                        mR=Interior_Model(ilayer).eta_variable(i,2);
                        eta_stokes.clm(nR+1,mR+1)=sqrt(2)*real(Interior_Model(ilayer).eta_variable(i,3));
                        eta_stokes.slm(nR+1,mR+1)=-sqrt(2)*imag(Interior_Model(ilayer).eta_variable(i,3));
                    elseif Interior_Model(ilayer).eta_variable(i,2)<0               
                    else
                        nR=Interior_Model(ilayer).eta_variable(i,1);
                        mR=Interior_Model(ilayer).eta_variable(i,2);
                        amplitude=Interior_Model(ilayer).eta_variable(i,3);
                        eta_stokes.clm(nR+1,mR+1)=amplitude;
                    end
                end

                % Convert to a lat-lon grid
                [eta_zlonlat] = SPH_LatLon(eta_stokes);

                % Save the lat-lon grid as eta_latlon_set_internal
                Interior_Model(ilayer).eta_latlon_set_internal = eta_zlonlat;
            end
    
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % When the viscosity and/or shear modulus fields are directly
            % given, the procedure is slightly different as it is assumed
            % that what is given is the entire field not just the deviation
            % from the mean.

            % Maxwell time
            MaxTime_zlonlat.lon=mu_zlonlat.lon;
            MaxTime_zlonlat.lat=mu_zlonlat.lat;
            MaxTime_zlonlat.lmax=mu_zlonlat.lmax;
            if ~isempty(Interior_Model(ilayer).eta_latlon) && ~isempty(Interior_Model(ilayer).mu_latlon)
                MaxTime_zlonlat.z = eta_zlonlat.z./mu_zlonlat.z;%/(2*pi); % 2 pi has to be added for consistency reasons
            else
                MaxTime_zlonlat.z = (1+eta_zlonlat.z)./(1+mu_zlonlat.z);
            end
            
            % Complex Shear modulus
            Cmu_zlonlat.lon=mu_zlonlat.lon;
            Cmu_zlonlat.lat=mu_zlonlat.lat;
            Cmu_zlonlat.lmax=mu_zlonlat.lmax;
            if ~isempty(Interior_Model(ilayer).mu_latlon)
                Cmu_zlonlat.z = Interior_Model(ilayer).mu*(mu_zlonlat.z)./ ...
                        (1-1i./(MaxTime_zlonlat.z * Interior_Model(ilayer).MaxTime));
            else
                Cmu_zlonlat.z = Interior_Model(ilayer).mu*(1+mu_zlonlat.z)./ ...
                        (1-1i./(MaxTime_zlonlat.z * Interior_Model(ilayer).MaxTime));
            end

            % find spherical harmonics coefficients
            % real part 
            muR_zlonlat.lon=mu_zlonlat.lon;
            muR_zlonlat.lat=mu_zlonlat.lat;
            muR_zlonlat.lmax=mu_zlonlat.lmax;
            muR_zlonlat.z=real(Cmu_zlonlat.z);
            [muR_SPH]=LatLon_SPH(muR_zlonlat);

            %imaginary part
            muI_zlonlat.lon=mu_zlonlat.lon;
            muI_zlonlat.lat=mu_zlonlat.lat;
            muI_zlonlat.lmax=mu_zlonlat.lmax;
            muI_zlonlat.z=imag(Cmu_zlonlat.z);
            [muI_SPH]=LatLon_SPH(muI_zlonlat);

            % set components in the right format for the code
            vec_n=0:1:2*l_max-1;
            vec_m=-2*l_max+1:1:2*l_max-1;
            [m_g, n_g]=meshgrid(vec_m,vec_n);
            muR_aux=zeros(size(m_g));
            muI_aux=zeros(size(m_g));
            for i=1:length(vec_n) %degree 
                for j=1:vec_n(i)+1 %order
                    if vec_n(j)==0
                        indexN=find(vec_n(j)==m_g & vec_n(i)==n_g);
                        muR_aux(indexN)=muR_aux(indexN)+muR_SPH.clm(i,j);
                        muI_aux(indexN)=muI_aux(indexN)+muI_SPH.clm(i,j);
                    else
                        indexN1=find(vec_n(j)==m_g & vec_n(i)==n_g); %positive m
                        indexN2=find(-vec_n(j)==m_g & vec_n(i)==n_g); %negative m
                        % REAL mu
                        %positive m
                        muR_aux(indexN1)=muR_aux(indexN1)+1/sqrt(2)*muR_SPH.clm(i,j);
                        muR_aux(indexN1)=muR_aux(indexN1)-(-1)^vec_n(j)*1i/sqrt(2)*muR_SPH.slm(i,j)*sine_component_factor;
                        %negative m
                        muR_aux(indexN2)=muR_aux(indexN2)+(-1)^vec_n(j)/sqrt(2)*muR_SPH.clm(i,j);
                        muR_aux(indexN2)=muR_aux(indexN2)+1i/sqrt(2)*muR_SPH.slm(i,j)*sine_component_factor;
                        % IMAGINARY mu 
                        muI_aux(indexN1)=muI_aux(indexN1)+1/sqrt(2)*muI_SPH.clm(i,j);
                        muI_aux(indexN1)=muI_aux(indexN1)-(-1)^vec_n(j)*1i/sqrt(2)*muI_SPH.slm(i,j)*sine_component_factor;
                        %negative m
                        muI_aux(indexN2)=muI_aux(indexN2)+(-1)^vec_n(j)/sqrt(2)*muI_SPH.clm(i,j);
                        muI_aux(indexN2)=muI_aux(indexN2)+1i/sqrt(2)*muI_SPH.slm(i,j)*sine_component_factor;
                    end
                end
            end

            % 0,0 component
            index0=find(n_g==0 & m_g==0);
            mu00R=muR_aux(index0);
            mu00I=muI_aux(index0);
            mu00=mu00R+1i*mu00I; % Will be normalized later
            Interior_Model(ilayer).muC=mu00;

            % Find components that are bigger than some quantity, this is an approximation 
            muI_aux2=log10(abs(muI_aux/muI_SPH.clm(1,1)));
            muR_aux2=log10(abs(muR_aux/muR_SPH.clm(1,1)));
            muI_aux2(index0)=log10(0);
            muR_aux2(index0)=log10(0); 
            muI_max=max(muI_aux2(:));
            muR_max=max(muR_aux2(:));
            mu_max=max([muR_max muI_max]);
            non_zero_indexes=find((muI_aux2-mu_max>=-Numerics.rheology_cutoff | muR_aux2-mu_max>=-Numerics.rheology_cutoff) & ...
                                   mu_max > Numerics.minimum_rheology_value);
            k=1;
            % Check whether any rheology modes are big enough to be usable
            if ~isempty(non_zero_indexes)
                for i=1:length(non_zero_indexes)
                    if n_g(non_zero_indexes(i))>0
                        Interior_Model(ilayer).rheology_variable(k,1)=n_g(non_zero_indexes(i)); 
                        Interior_Model(ilayer).rheology_variable(k,2)=m_g(non_zero_indexes(i)); 
                        Interior_Model(ilayer).rheology_variable(k,4)=(muR_aux(non_zero_indexes(i))+1i*muI_aux(non_zero_indexes(i)));
                        k=k+1;
                    end
                end
                Interior_Model(ilayer).mu00R=mu00R;
    
                % PLOT THE RHEOLOGY STRUCTURE TO CHECK
                % There is an internal check whether it will plot or not.
                plot_rheology_map(plot_rheology_spectra,mu_zlonlat,eta_zlonlat, ...
                                  MaxTime_zlonlat,Interior_Model(ilayer),Cmu_zlonlat, ...
                                  m_g,n_g,muI_aux,muI_SPH,muR_aux,muR_SPH, ...
                                  mu00I,non_zero_indexes)

            % If there are no modes big enough the layer becomes uniform
            else
                Interior_Model(ilayer).uniform=1;
                muC=Interior_Model(ilayer).mu*(1-1i/Interior_Model(ilayer).MaxTime)^(-1);
                mu00R=real(muC);
                mu00I=imag(muC);
                mu00=mu00R+1i*mu00I;
                Interior_Model(ilayer).muC=mu00;
                Interior_Model(ilayer).mu00R=mu00R;
                Interior_Model(ilayer).rheology_variable=[0 0 0 0];
            end
            
        % Uniform model
        else
            muC=Interior_Model(ilayer).mu*(1-1i/Interior_Model(ilayer).MaxTime)^(-1);
            mu00R=real(muC);
            mu00I=imag(muC);
            mu00=mu00R+1i*mu00I;
            Interior_Model(ilayer).muC=mu00;
            Interior_Model(ilayer).mu00R=mu00R;
            Interior_Model(ilayer).rheology_variable=[0 0 0 0];
        end
    else %elastic
        if Interior_Model(ilayer).uniform==1
            Interior_Model(ilayer).rheology_variable=[0 0 0 0];
            Interior_Model(ilayer).muC=Interior_Model(ilayer).mu;
            Interior_Model(ilayer).mu00R=Interior_Model(ilayer).mu;
        else
            Interior_Model(ilayer).rheology_variable(:,[1 2])=Interior_Model(ilayer).mu_variable(:,[1 2]);
            Interior_Model(ilayer).rheology_variable(:,3)=0;
            Interior_Model(ilayer).rheology_variable(:,4)=Interior_Model(ilayer).mu_variable(:,3);
            Interior_Model(ilayer).muC=Interior_Model(ilayer).mu;
            Interior_Model(ilayer).mu00R=Interior_Model(ilayer).mu;
        end
    end
end


%% Re-normalize if asked for
if calculate_G
    for ilayer=1:Numerics.Nlayers
        if ilayer > 1
            % Calculate Lambda
            Interior_Model(ilayer).lambda=Interior_Model(ilayer).Ks - 2/3*Interior_Model(ilayer).muC;

            % Redundancy
            if Interior_Model(ilayer).uniform==1
                Interior_Model(ilayer).rheology_variable=[0 0 0 0];
            end
            
            % Fill an array with all the modes that are active/used
            if ilayer == 2
                rheo_degree_orders = Interior_Model(ilayer).rheology_variable(:,1:2);
            else
                rheo_degree_orders = [rheo_degree_orders ; Interior_Model(ilayer).rheology_variable(:,1:2)];
            end
        end
    end
else % Legacy normalization only used for comparisons to older data
    for ilayer=1:Numerics.Nlayers
        % Re-normalize Gg only using the values of the last layer
        Interior_Model(ilayer).Gg = Interior_Model(ilayer).Gg/Interior_Model(end).mu00R;
        if ilayer > 1
            % Re-normalize the 00 element of the rheology
            Interior_Model(ilayer).muC = Interior_Model(ilayer).muC/Interior_Model(end).mu00R;
            
            % Calculate Lambda
            Interior_Model(ilayer).lambda=Interior_Model(ilayer).Ks/Interior_Model(end).mu00R - 2/3*Interior_Model(ilayer).muC;
            if Interior_Model(ilayer).uniform==1
                Interior_Model(ilayer).rheology_variable=[0 0 0 0];
            end
            
            % Re-normalize the rheology_variable
            Interior_Model(ilayer).rheology_variable(:,4) = Interior_Model(ilayer).rheology_variable(:,4)/...
                                                                Interior_Model(end).mu00R;
            
            % Fill an array with all the modes that are active/used
            if ilayer == 2
                rheo_degree_orders = Interior_Model(ilayer).rheology_variable(:,1:2);
            else
                rheo_degree_orders = [rheo_degree_orders ; Interior_Model(ilayer).rheology_variable(:,1:2)];
            end
        end
    end
end

% Next we make sure that the size of the rheology_variable is the same for all
% layers. Modes that are not part of the original response are set to zero

% Remove duplicates from rheo_degree_orders
rheo_degree_orders = unique(rheo_degree_orders,'rows');

for ilayer=2:Numerics.Nlayers
    if (Interior_Model(ilayer).uniform==0) & (Interior_Model(ilayer).elastic==0)
        % Matrix to be filled, will replace Interior_Model.rheology_variable
        temp_rheology_var = zeros(length(rheo_degree_orders(:,1)),4);
    
        % Fill with all the active/used degrees and orders
        temp_rheology_var(:,1:2) = rheo_degree_orders;
    
        % Loop over all active modes and test whether a layer has a value for 
        % that mode. Fill the temp_rheology_var with the amplitudes
        for i=1:length(temp_rheology_var(:,1))
            n_rheo_tot = temp_rheology_var(i,1);
            m_rheo_tot = temp_rheology_var(i,2);
            ind_mode = find(Interior_Model(ilayer).rheology_variable(:,1)==n_rheo_tot & ...
                           Interior_Model(ilayer).rheology_variable(:,2)==m_rheo_tot);
            if ~isempty(ind_mode)
                temp_rheology_var(i,4) = Interior_Model(ilayer).rheology_variable(ind_mode,4);
            end
        end
    
        % Reset the rheology_variable such that all layers are the same size
        Interior_Model(ilayer).rheology_variable = temp_rheology_var;
    end
end

end
